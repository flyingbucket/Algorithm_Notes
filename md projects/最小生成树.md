# 最小生成树

## 概念和问题陈述

定义(生成树与最小生成树):
生成树是指一个连通图中的子树, 它包含图中所有顶点, 并且连接了所有顶点, 但不包含回路.
最小生成树(MST)是指连接所有顶点的权重和最小的生成树.

问题:
给定一个无向连通图G=(V,E), 其中V为顶点集, E为边集,边的权重函数W:E->R, 求G的最小生成树(MST), 即在G中, 权重和最小的生成树.
(为了简化问题,假设G中所有边的的权重各不相同)

## 最优子结构性质

定义(树的导出图):
树T的所有顶点记为V,以V为顶点的完全无向图G的边集为E,则对任意E的子集E',称G'=(V,E')为T的一个导出图.

定理(最小生成树的最有子结构性质):
对于某图G的最小生成树T,任意删去一条边,则得到两个子树T1和T2,它们的任意导出图分别为G1和G2,则T1和T2分别是G1和G2的最小生成树.
证明(剪贴法):
W(T)=W(u,v)+W(T1)+W(T2),其中(u,v)为被移除的边,T1,T2为由此产生的子树;设G1,G2为T1,T2的导出图;
假设T1'是G1的最小生成树,$T1'!=T1$,则对于$T'={(u,v)} \cup T1' \cup T2$,有$W(T')<W(u,v)+W(T1')+W(T2)$,与T是G的最小生成树矛盾.
因此,T1,T2是G1,G2的最小生成树.


## 重叠子问题性质

递归过程可以理解成不断移除边的过程,按不同顺序移除所得到的结果本质上是相同的,从而得到很多重叠子问题.
**由此可见求解此问题可以使用动态规划,但实际上最小生成树问题有一个更强的性质,使得我们可以使用贪心算法来求解**



## 贪心选择属性

含义:
局部最优解也是全局最优解

以下内容均对无向连通图G=(V,E)进行分析.

定义(顶点到顶点集的距离):对于顶点v和顶点集合S,v到S中任意顶点u的简单路径的权重和称为v
到u的距离,定义d(v,S)为$min \{d(v,u)|u \in S \}$.

定义:(S,V-S)是V的一个划分,如果边(u,v)一个顶点在S,另一个顶点在V-S,则称(u,v)横跨分割(S,V-S).

定义:横跨(S,V-S)的边中权重最小的称为(S,V-S)的轻量级边.

定义:设边集A是E的一个子集,(S,V-S)是V的一个划分,若A中没有边横跨分割(S,V-S),则称(S,V-S)"尊重"A的划分.

定义:如果边集A是G的MST的子集,$A \cup (u,v)$ 仍是MST的子集,则称(u,v)是A的安全边.

定理:设A是G的MST的子集,对于任意尊重A的划分(S,V-S),(S,V-S)的轻量级边(u,v)必为A的安全边.
证明:
设G的MST为T,即证(u,v)在T中,用反证法.假设(u,v)不在T中.
由于T是G的MST,故在T中存在u到v的简单路径,又由于(u,v)横跨划分(S,V-S),故该路径上比有一条边横跨分割(S,V-S),设该边为(x,y);
将(x,y)从T删除,则T被划分为两个子树,T1和T2,用(u,v)连接T1和T2,得到新的生成树T',且其总权重小于T,与T是G的MST矛盾.
因此,T包含边(u,v).

推论:设G的MST为T,A是T的边集的子集,对于森林$G_A=(V,A)$中的任意树T'和T'',若边(u,v)是T'与T''的轻量级边,则(u,v)是A的安全边.

## 求解算法

基本思路是:先将A设置为空集,然后不断选择安全边加入A中(第一条安全边显然是G 中权重最小的边),直到A成为G的MST.

### Kruskal算法

待补充

### Prim算法

在Prim算法中,设S是边集合A所包含的顶点的集合,Prim算法的特点是G'=(S,A)总是构成一个树,初始时A为空集,然后加入图中权重最小的边,将剩余节点构成的集合V-S记为Q;为Q中的每个节点v,赋予key值,key值为节点v到顶点集S的距离,按此key值将Q维护成优先队列,key值越小优先度越高;不断从Q中取出key值最小的节点v,将其加入S中,记录下Q到S的轻量级边,将其i添加到A中,最后更新Q中的所有节点的key值,直到Q为空.此时S=V,图(V,A)为G的MST.

伪代码

```{.line-numbers}
DISTENT-AND-EDGE(v,S):
    tmp=[]
    for u in S:
        if (u,v) in E:
            tmp.append((w(u,v),(u,v)))
        heapfy(tmp,key=lambda x:x[0])
        return tmp[0][0],tmp[0][1]

MST-PRIM(G,w):
    A = {}
    S = {}
    u,v=LEAST-WEIGHT-EDGE(G)
    A.add(u,v)
    S.add(u,v)
    Q = V-{u,v}
    for v in Q:
        v.key,v.edge=DISTENT-AND-PARENT(v,S)
    while Q is not empty:
        tmp=Q.pop()
        A.add(tmp.edge)
        S.add(tmp)
    return A
```
