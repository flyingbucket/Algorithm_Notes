---
html: 
    toc: true
---

# 二叉搜索树

## 定义

二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树，每个节点都是一个对象,每个对象包含的属性为卫星数据、key、左孩子、右孩子和父节点。
其中key是节点的唯一标识，左孩子指针指向左子树的根节点，右孩子指针指向右子树的根节点，父节点指针指向父节点。

```python{/line-numbers}
class BSTreeNode:
    def __init__(self, val,Optional:hash):
        self.val = val  # 卫星数据
        if hash is None:
            self.key = val  # key
        else:
            self.key = hash(val)  # key
        self.left = None  # 左孩子指针
        self.right = None # 右孩子指针
        self.parent = None # 父节点指针
```

## 性质
x=Node(val,hash)
- 左子树中的**所有节点**的值均小于根节点的值: x.left.val < x.val
- 右子树中的**所有节点**的值均大于根节点的值: x.right.val > x.val
- 左右子树也分别为二叉搜索树。
- 没有键值相等的节点。

## 中序遍历
先序遍历：根左右
中序遍历：左根右
后序遍历：左右根

在中序遍历下，二叉搜索树将按key值升序输出。
```plaintext{.line-numbers}
IN-ORDER-TREE-WALK(x):
    if x is not None:
        IN-ORDER-TREE-WALK(x.left)
        print(x.key )
        IN-ORDER-TREE-WALK(x.right)
```
用代入法可以验证，中序遍历的时间复杂度为$\Theta(n)$。

## 构建
由上述性质可知，要将一个数组维护成二叉搜索树，首先要对它排序；然后对已排序的数组的左半部分和右半部分递归地进行维护。

```python{.line-numbers}
class BST:
    def __init__(self,arr=None):
        if not arr or len(arr)==0: #不传入arr或传入arr为空时，构造空树
            self.root=None
        else:
            self.root=__build_bst(arr)

    def __build_bst(arr):
        sort(arr)
        if not arr:
            return None
        mid=len(arr)//2
        root=Node(arr[mid])
        root.left=build_bst(arr[:mid])
        root.right=build_bst(arr[mid+1:])
        root.left.parent=root
        root.right.parent=root
        return root

```
## 查询
要查询一个关键字为k的节点，可以先从根节点查起，如果根节点的key等于k，则返回根节点；如果k小于根节点的key，则在左子树中继续查询；如果k大于根节点的key，则在右子树中继续查询。
```plaintext{.line-numbers}
TREE-SEARCH(x,k):
    if x==None or x.key==k:
        return x
    elif k<x.key:
        return TREE-SEARCH(x.left,k)
    else:
        return TREE-SEARCH(x.right,k)
```

查询的时间复杂度为$\Theta(h)$，h为树的高度。

在大多数计算机上while循环往往效率更高，所以可以用while循环实现树的查询：

```plaintext{.line-numbers}
TREE-SEARCH(x,k):
    while x!= None and x.key!=k:
        if k < x.key:
            x=x.left
        else:
            x=x.right
    return x
```

## 最大最小值
从根节点开始，不断取左孩子，直到触底即可找到最小值，同理，从根节点开始，不断取右孩子，直到触底即可找到最大值。
```plaintext{.line-numbers}
TREE-MINIMUM(x):
    while x.left!= None:
        x=x.left
    return x

TREE-MAXIMUM(x):    
    while x.right!= None:
        x=x.right
    return x
```
取最小值和最大值的时间复杂度为$\Theta(h)$，h为树的高度。

## 前驱与后继

前驱：当前节点的左子树中的最大节点。
后继：当前节点的右子树中的最小节点。

