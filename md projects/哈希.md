---
html:
    toc: true
---

# 哈希
首先我们假设带存储的数据集为D，对于$\forall x \in D$，x都有一个关键字属性x.key，U中每个元素的关键字都是唯一的。

## 哈希表
**哈希表(Hash Table)**是一种数据结构，它通过一个**哈希函数**将带存储数据的关键字(key)映射到一个整数作为某特定的数组索引，然后将该关键字对应的数据存储到该数组的该索引下。
*python的字典类型数据就是一种典型的哈希表*

因此哈希表支持通过关键字查询，同时能够以O(1)的时间复杂度实现查询。
数组可以实现快速查询，链表可以实现按关键字查询，而哈希表则结合了两者的优势。

采用不同的哈希函数构建出的哈希表往往是不同的。

### 直接寻址表
对于某一类型的数据，所有可能的关键字数量往往比较大，而实际需要存储的数据并不多；
举个例子
```
在存储公民信息的场景下，18位身份证号就是关键字，17位数字加一位字母所构建出的、所有可能的身份证号的数量远多于中国人口。
```
我们将所有可能的关键字构成的集合称为全域，记作U，所有实际被使用的关键字构成的集合记作K，显然$k \subseteq U$.

当U的规模不大时，我们采用**直接寻址表**T，即构造一个单射哈希函数，将全域中所有可能的键映射为T的索引，然后将数据存储到T数组中，如果某个关键字属于U而不属于K，即该关键字未被使用，我们规定该关键字在T中对应的位置存储NIL(空)。

### 哈希表
当U规模较大且U与K规模差距悬殊时，采用直接寻址会造成很严重的浪费，此时我们构造一个非单射的哈希函数，将U映射到一个规模较小的整数集上。
举个例子
```
要存储五个人的信息，他们同名同姓，都叫张伟，此时名字就不能当作关键字了；
我们采用身份证号作为关键字，假设他们五人的身份证号全是数字构成的，不含字母，
如果采用直接寻址，将所有18位身份证号都存储到数组T中，那么T的长度将是亿亿级别的，实际T只存储5个人的数据，那么T会有大量的NIL浪费；
此时，我们可以用他们的身份证号模5取余，假设这五个人的身份证号模5取余后没有重复，
将这个余数作为索引，我们就可以把这五个人的数据存储到一个五位长的数组中，
如果模5取余有重复，那么我们可以考虑更换哈希函数，比如模10取余，或者模更大的数字。
```
如果我们对K中的两个不同关键字做哈希运算后，得到两个相同的索引，那么称这种情况位“冲突”(collision)。处理冲突时，并不一定要更换哈希函数来避免冲突，在某些时候冲突甚至不可避免。

### 链表法
将被映射到同一索引下的元素用双向链表组织起来，哈希表的索引下存储一个指针指向链表的表头；查询时，输入的关键字先被哈希函数映射为哈希表索引，然后根据索引找到链表表头，再利用关键字在链表中查找。
链表法直观易懂，通常是有效的；但在特殊情况下，如果大量元素在同一索引下发生冲突，该索引的链表过长，由于链表的查询、添加、删除都是O(n)操作，故此时哈希表的性能会严重下降。
设T的槽位数为m，U的规模为n，定义T的**装载因子**为$\alpha=n/m$
假设在哈希函数h的映射下，U中每个关键字被放入m个槽位的可能性都是1/m,称此假设为简单均匀假设；在这种假设下，每个关键字的最坏查询时间为$\Theta(1+\alpha)$。

## 哈希函数
各类关键字都有一定的办法、规则来转化成整数，比如说我们可以用ASCII将字符串转化为整数。在后面的分析中，我们都假定关键字已经被转化为整数。

### 除法散列法
$$h(k)=k mod m$$
在十进制下，如果选择$10^x$为基数m，那么关键字只有最后的x位会在哈希函数的计算中起作用；同理，在计算机的二进制世界中，我们也不应选择$2^X$作为基数m。
如果我们希望链表的长度被控制在r，那么我们可以选择一个n/r附近的，尽可能远离任何2的次幂的素数。

### 乘法散列法
$$h(k)=\lfloor m(kA mod) 1 ,A \in (0,1)$$
在乘法散列法中，首先我们个k乘以一个小数并取乘积的小数部分，然后给取出的小数部分乘以m。
这个方法的好处就在于，m的选择比“除法散列法”更自由。

### 全域哈希
哈希表这种存储方法应用极其广泛，比如说一个网站而可能用哈希表来存储用户的信息，如果一个黑客要攻击网站的服务器，他可以根据该网站选取的哈希函数设计大量的关键字，使得这些关键字都被存储到一个槽位。为了避免这种恶意攻击或者某些特定的关键字输入，我们可以采取随机化的方法，从多个精心设计的哈希函数中随机选择一个进行哈希。